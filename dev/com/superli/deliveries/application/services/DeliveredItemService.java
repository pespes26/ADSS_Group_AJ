package com.superli.deliveries.application.services;

import java.sql.SQLException;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import com.superli.deliveries.domain.core.DestinationDoc;
import com.superli.deliveries.domain.core.Product;
import com.superli.deliveries.domain.core.Transport;
import com.superli.deliveries.domain.core.Truck;
import com.superli.deliveries.domain.core.DeliveredItem;
import com.superli.deliveries.dataaccess.dao.DeliveredItemDAO;
import com.superli.deliveries.dto.DeliveredItemDTO;
import com.superli.deliveries.Mappers.DeliveredItemMapper;
/**
 * Service responsible for managing delivered items within destination documents.
 * Also handles weight calculation and validation.
 */
public class DeliveredItemService {

    private final DeliveredItemDAO deliveredItemDAO;
    private final TransportService transportService;
    private final ProductService productService;

    public DeliveredItemService(DeliveredItemDAO deliveredItemDAO,
                                TransportService transportService,
                                ProductService productService) {
        this.deliveredItemDAO = deliveredItemDAO;
        this.transportService = transportService;
        this.productService = productService;
    }

    /**
     * Adds a new delivered item to an existing destination doc.
     * @param docId DestinationDoc ID.
     * @param item The delivered item to add.
     * @return true if added successfully, false otherwise.
     */
    public boolean addDeliveredItem(String docId, DeliveredItem item) {
        try {
            // Check if weight limit would be exceeded
            if (wouldExceedWeightLimit(docId, item)) {
                System.out.println("⚠️ Warning: Adding this item would exceed the truck's weight limit.");
                return false;
            }

            DeliveredItemDTO dto = DeliveredItemMapper.toDTO(item, docId); // ID will be generated by DB
            deliveredItemDAO.save(dto);

            // Update the transport's departure weight
            updateTransportWeight(docId);

            return true;
        } catch (SQLException e) {
            throw new RuntimeException("Error adding delivered item", e);
        }
    }

    /**
     * Removes a delivered item from a destination doc.
     * @param docId DestinationDoc ID.
     * @param item The delivered item to remove.
     * @return true if removed, false otherwise.
     */
    public boolean removeDeliveredItem(String docId, DeliveredItem item) {
        try {
            List<DeliveredItemDTO> items = deliveredItemDAO.findAll();
            Optional<DeliveredItemDTO> itemToRemove = items.stream()
                    .filter(dto -> dto.getDestinationDocId().equals(docId) && 
                                 dto.getProductId().equals(item.getProductId()))
                    .findFirst();

            if (itemToRemove.isPresent()) {
                deliveredItemDAO.deleteById(itemToRemove.get().getId());

                // Update the transport's departure weight
                updateTransportWeight(docId);
                return true;
            }
            return false;
        } catch (SQLException e) {
            throw new RuntimeException("Error removing delivered item", e);
        }
    }

    /**
     * Retrieves all delivered items for a specific destination doc.
     * @param docId The ID of the destination document.
     * @return A list of delivered items, or an empty list if not found.
     */
    public List<DeliveredItem> getDeliveredItemsForDoc(String docId) {
        try {
            return deliveredItemDAO.findAll().stream()
                    .filter(dto -> dto.getDestinationDocId().equals(docId))
                    .map(DeliveredItemMapper::fromDTO)
                    .collect(Collectors.toList());
        } catch (SQLException e) {
            throw new RuntimeException("Error getting delivered items for doc: " + docId, e);
        }
    }

    /**
     * Updates the quantity of a delivered item for a specific product.
     * @param docId DestinationDoc ID.
     * @param productId Product ID of the delivered item to update.
     * @param newQuantity The new quantity to set.
     * @return true if the item was found and updated, false otherwise.
     */
    public boolean updateQuantity(String docId, String productId, int newQuantity) {
        try {
            List<DeliveredItemDTO> items = deliveredItemDAO.findAll();
            Optional<DeliveredItemDTO> itemToUpdate = items.stream()
                    .filter(dto -> dto.getDestinationDocId().equals(docId) && 
                                 dto.getProductId().equals(productId))
                    .findFirst();

            if (itemToUpdate.isPresent()) {
                DeliveredItemDTO dto = itemToUpdate.get();
                DeliveredItem tempItem = new DeliveredItem(productId, newQuantity);
                
                // Check weight limit with the new quantity
                if (wouldExceedWeightLimit(docId, tempItem)) {
                    System.out.println("⚠️ Warning: New quantity would exceed the truck's weight limit.");
                    return false;
                }

                dto.setQuantity(newQuantity);
                deliveredItemDAO.save(dto);

                // Update the transport's departure weight
                updateTransportWeight(docId);

                return true;
            }
            return false;
        } catch (SQLException e) {
            throw new RuntimeException("Error updating quantity", e);
        }
    }

    /**
     * Calculates the total weight of all items in a destination document
     * @param docId The document ID
     * @return The total weight, or 0 if document not found
     */
    public float calculateDocumentWeight(String docId) {
        List<DeliveredItem> items = getDeliveredItemsForDoc(docId);
        float totalWeight = 0;

        for (DeliveredItem item : items) {
            Optional<Product> productOpt = productService.getProductById(item.getProductId());
            if (productOpt.isPresent()) {
                totalWeight += productOpt.get().getWeight() * item.getQuantity();
            }
        }

        return totalWeight;
    }

    /**
     * Calculates the total weight of all items in all documents for a transport
     * @param transportId The transport ID
     * @return The total weight of all documents
     */
    public float calculateTotalTransportWeight(String transportId) {
        Optional<Transport> transportOpt = transportService.getTransportById(transportId);
        if (transportOpt.isEmpty()) {
            return 0;
        }

        Transport transport = transportOpt.get();
        float totalWeight = 0;

        for (DestinationDoc doc : transport.getDestinationDocs()) {
            totalWeight += calculateDocumentWeight(doc.getDestinationDocId());
        }

        return totalWeight;
    }

    /**
     * Checks if adding an item would exceed the truck's weight limit
     * @param docId The document ID
     * @param item The item to check
     * @return true if adding the item would exceed the limit
     */
    private boolean wouldExceedWeightLimit(String docId, DeliveredItem item) {
        float currentWeight = calculateDocumentWeight(docId);
        Optional<Product> productOpt = productService.getProductById(item.getProductId());
        
        if (productOpt.isPresent()) {
            float itemWeight = productOpt.get().getWeight() * item.getQuantity();
            float totalWeight = currentWeight + itemWeight;

            // Get the transport's truck
            Optional<Transport> transportOpt = transportService.getTransportById(docId);
            if (transportOpt.isPresent()) {
                Truck truck = transportOpt.get().getTruck();
                return totalWeight > truck.getMaxWeight();
            }
        }
        return false;
    }

    /**
     * Updates the transport's departure weight based on all items in its documents
     * @param docId The document ID
     */
    private void updateTransportWeight(String docId) {
        Optional<Transport> transportOpt = transportService.getTransportById(docId);
        if (transportOpt.isPresent()) {
            Transport transport = transportOpt.get();
            float totalWeight = calculateTotalTransportWeight(transport.getTransportId());
            transport.setDepartureWeight(totalWeight);
            transportService.saveTransport(transport);
        }
    }
}